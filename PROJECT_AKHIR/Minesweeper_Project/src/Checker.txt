import javax.swing.*;

public class Minesweeper{
    public static void main(String[] args) {
        JFrame frame = new JFrame("Minesweeper");
        SettingsFrame settingsFrame = new SettingsFrame();

        frame.add(frame, settingsFrame, 0);
    }
}
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class SettingsFrame extends JFrame implements ActionListener {
    private JTextField rowsField;
    private JTextField colsField;
    private JTextField numMinesField;

    public SettingsFrame() {
        setTitle("Minesweeper Game!");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setResizable(false);

        JPanel panel = new JPanel(new GridLayout(4, 2));

        panel.add(new JLabel("Rows:"));
        rowsField = new JTextField("");
        rowsField.setPreferredSize(new Dimension(150, 20));
        panel.add(rowsField);
        panel.add(new JLabel("Columns:"));
        colsField = new JTextField("");
        colsField.setPreferredSize(new Dimension(150, 20));
        panel.add(colsField);
        panel.add(new JLabel("Number of Mines:"));
        numMinesField = new JTextField("");
        numMinesField.setPreferredSize(new Dimension(150, 20));
        panel.add(numMinesField);

        JButton startButton = new JButton("Start Game");
        startButton.setPreferredSize(new Dimension(120, 20));
        startButton.addActionListener(this);
        panel.add(startButton);

        JButton cancelButton = new JButton("Cancel");
        cancelButton.setPreferredSize(new Dimension(120, 20));
        cancelButton.addActionListener(this);
        panel.add(cancelButton);

        add(panel);

        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("Start Game")) {
            try {
                int rows = Integer.parseInt(rowsField.getText());
                int cols = Integer.parseInt(colsField.getText());
                int numMines = Integer.parseInt(numMinesField.getText());

                GameFrame gameFrame = new GameFrame(rows, cols, numMines);
                dispose();
            } catch (NumberFormatException ex) {
                JOptionPane.showMessageDialog(this, "Please enter valid numbers.");
            }
        } else if (e.getActionCommand().equals("Cancel")) {
            dispose();
        }
    }
}

import javax.swing.*;

public class GameFrame extends JFrame {
    private Board board;

    public GameFrame(int rows, int cols, int numMines) {
        setTitle("Minesweeper");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(400, 400);
        setResizable(false);
        
        board = new Board(rows, cols, numMines);
        board.placeMines();
        add(board);
        
        
        pack();
        setLocationRelativeTo(null);
        setVisible(true);
    }
}
import javax.swing.*;

public class GameBoard extends JButton {
    private int row;
    private int col;
    private boolean isMine;
    private boolean isFlagged;
    private boolean isRevealed;

    public GameBoard(int row, int col) {
        this.row = row;
        this.col = col;
        this.isMine = false;
        this.isFlagged = false;
        this.isRevealed = false;
    }

    public int getRow() {
        return row;
    }

    public int getCol() {
        return col;
    }

    public boolean isMine() {
        return isMine;
    }

    public void setMine(boolean mine) {
        isMine = mine;
    }

    public boolean isFlagged() {
        return isFlagged;
    }

    public void setFlagged(boolean flagged) {
        isFlagged = flagged;
    }

    public boolean isRevealed() {
        return isRevealed;
    }

    public void setRevealed(boolean revealed) {
        isRevealed = revealed;
    }
}
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Board extends JPanel implements ActionListener {
    private int rows;
    private int cols;
    private int numMines;
    private GameBoard[][] cells;

    public Board(int rows, int cols, int numMines) {
        this.rows = rows;
        this.cols = cols;
        this.numMines = numMines;
        this.cells = new GameBoard[rows][cols];

        setLayout(new GridLayout(rows, cols));
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                GameBoard cell = new GameBoard(row, col);
                cell.setPreferredSize(new Dimension(20, 20));
                cell.addActionListener(this);
                cells[row][col] = cell;
                add(cell);
            }
        }
    }

    public void actionPerformed(ActionEvent e) {
        GameBoard cell = (GameBoard) e.getSource();
        int row = cell.getRow();
        int col = cell.getCol();
        if (!cell.isFlagged()) {
            if (cell.isMine()) {
                revealAllMines();
                JOptionPane.showMessageDialog(this, "Game Over!");
            } else {
                int numAdjacentMines = getNumAdjacentMines(row, col);
                if (numAdjacentMines == 0) {
                    revealEmptyCells(row, col);
                } else {
                    cell.setText(String.valueOf(numAdjacentMines));
                }
                cell.setRevealed(true);
                checkWin();
            }
        }
    }

    private int getNumAdjacentMines(int row, int col) {
        int numAdjacentMines = 0;
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                int r = row + i;
                int c = col + j;
                if (r >= 0 && r < rows && c >= 0 && c < cols){
                    if (cells[r][c].isMine()) {
                        numAdjacentMines++;
                    }
                }
            }
        }
        return numAdjacentMines;
    }

    private void revealEmptyCells(int row, int col) {
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                int r = row + i;
                int c = col + j;
                if (r >= 0 && r < rows && c >= 0 && c < cols) {
                    GameBoard cell = cells[r][c];
                    if (!cell.isMine() && !cell.isRevealed()) {
                        int numAdjacentMines = getNumAdjacentMines(r, c);
                        if (numAdjacentMines == 0) {
                            cell.setText("");
                            cell.setRevealed(true);
                            revealEmptyCells(r, c);
                        } else {
                            cell.setText(String.valueOf(numAdjacentMines));
                            cell.setRevealed(true);
                        }
                    }
                }
            }
        }
    }

    private void revealAllMines() {
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                GameBoard cell = cells[row][col];
                if (cell.isMine()) {
                    cell.setText("X");
                    cell.setRevealed(true);
                }
            }
        }
    }

    private void checkWin() {
        int numRevealedCells = 0;
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                GameBoard cell = cells[row][col];
                if (cell.isRevealed()) {
                    numRevealedCells++;
                }
            }
        }
        int numCells = rows * cols;
        int numSafeCells = numCells - numMines;
        if (numRevealedCells == numSafeCells) {
            revealAllMines();
            JOptionPane.showMessageDialog(this, "You Win!");
        }
    }

    public void placeMines() {
        int numMinesPlaced = 0;
        while (numMinesPlaced < numMines) {
            int row = (int) (Math.random() * rows);
            int col = (int) (Math.random() * cols);
            if (!cells[row][col].isMine()) {
                cells[row][col].setMine(true);
                numMinesPlaced++;
            }
        }
    }
}
